<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flowchart Minimalista</title>
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
  display: flex; 
  height: 100vh; 
  background: #fafafa;
  color: #333;
}

.sidebar { 
  width: 240px; 
  padding: 20px; 
  background: #fff;
  border-right: 1px solid #e5e5e5;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 600;
  color: #111;
}

button {
  padding: 8px 12px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
}

button:hover {
  background: #f8f8f8;
  border-color: #ccc;
}

button:active {
  transform: translateY(1px);
}

#clearFlow {
  background: #f5f5f5;
  color: #666;
  margin-top: 8px;
}

#clearFlow:hover {
  background: #eee;
}

.canvas-wrap { 
  flex: 1; 
  position: relative; 
  background: #fafafa;
}

.box { 
  position: absolute; 
  min-height: 70px; 
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  cursor: move; 
  padding: 12px;
  font-size: 12px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: box-shadow 0.15s ease;
  display: flex;
  flex-direction: column;
}

.box:hover {
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.box .header {
  display: flex;
  flex-direction: column;
  gap: 4px;
  position: relative;
}

.box .body {
  flex: 1;
  margin: 8px 0;
}

.box .footer {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: flex-start;
}

.box strong {
  font-size: 13px;
  font-weight: 600;
  display: block;
  margin-bottom: 4px;
}

.box small {
  color: #666;
  font-size: 11px;
}

.box.trigger { border-left: 3px solid #10b981; }
.box.questions { border-left: 3px solid #3b82f6; }
.box.decision { border-left: 3px solid #f59e0b; }
.box.flow { border-left: 3px solid #8b5cf6; }
.box.end { border-left: 3px solid #ef4444; }

.anchor { 
  width: 6px; 
  height: 6px; 
  border: 1px solid #999; 
  border-radius: 50%; 
  position: absolute; 
  background: #fff;
  transition: all 0.15s ease;
}

.anchor:hover {
  width: 8px;
  height: 8px;
  border-color: #666;
  background: #f0f0f0;
}

.anchor[data-pos="left"] { 
  left: -4px; 
  top: 50%; 
  transform: translateY(-50%); 
}

.anchor[data-pos="right"] { 
  right: -4px; 
  top: 50%; 
  transform: translateY(-50%); 
}

.anchor.active-anchor {
  border-color: #3b82f6;
  background: #3b82f6;
  width: 8px;
  height: 8px;
}

.conn-line { 
  stroke: #666; 
  stroke-width: 1.5; 
  fill: none;
  opacity: 0.8;
}

.json-section {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #e5e5e5;
}

.json-section strong {
  font-size: 12px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

pre { 
  font-size: 10px; 
  background: #f8f8f8; 
  padding: 12px; 
  border-radius: 6px;
  max-height: 200px; 
  overflow: auto;
  margin: 8px 0 0 0;
  border: 1px solid #e5e5e5;
  color: #555;
}

.anchor.hidden { display: none; }

.branches {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin: 8px 0;
}

.branches .branch-input { 
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.branches .branch-input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.add-branch {
  font-size: 10px;
  padding: 4px 8px;
  margin-top: 4px;
  background: #f8f8f8;
  color: #666;
  border: 1px solid #e5e5e5;
}

.add-branch:hover {
  background: #eee;
}

.del-box {
  position: absolute;
  top: 4px;
  right: 4px;
  padding: 2px 6px;
  font-size: 10px;
  background: #fee2e2;
  color: #dc2626;
  border: 1px solid #fecaca;
  border-radius: 4px;
  cursor: pointer;
}

.del-box:hover {
  background: #fecaca;
}

.key-input {
  margin-top: 4px;
  width: 100%;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.key-input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.title-input {
  width: 100%;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.title-input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.question-text {
  width: 100%;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.question-text:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.trigger-list .trigger-row {
  display: flex;
  gap: 4px;
  margin: 2px 0;
}

.trigger-list .trigger-input {
  flex: 1;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.trigger-list .trigger-input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.trigger-list .del-trigger {
  padding: 2px 6px;
  font-size: 10px;
  background: #fee2e2;
  color: #dc2626;
  border: 1px solid #fecaca;
  border-radius: 4px;
  cursor: pointer;
}

.trigger-list .del-trigger:hover {
  background: #fecaca;
}

.qopt-list .qopt-row {
  display: grid;
  grid-template-columns: 1fr 2fr auto;
  gap: 4px;
  margin: 2px 0;
}

.qopt-list .qopt-input {
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.qopt-list .qopt-input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.qopt-list .del-qopt {
  padding: 2px 6px;
  font-size: 10px;
  background: #fee2e2;
  color: #dc2626;
  border: 1px solid #fecaca;
  border-radius: 4px;
  cursor: pointer;
}

.qopt-list .del-qopt:hover {
  background: #fecaca;
}

.add-trigger {
  font-size: 10px;
  padding: 4px 8px;
  margin-top: 4px;
  background: #f8f8f8;
  color: #666;
  border: 1px solid #e5e5e5;
}

.add-trigger:hover {
  background: #eee;
}

.add-qopt {
  font-size: 10px;
  padding: 4px 8px;
  margin-top: 4px;
  background: #f8f8f8;
  color: #666;
  border: 1px solid #e5e5e5;
}

.add-qopt:hover {
  background: #eee;
}
</style>
</head>
<body>
<aside class="sidebar">
<h3>Flowchart</h3>
<button id="addTrigger">+ Trigger</button>
<button id="addQuestions">+ Questions</button>
<button id="addDecision">+ Decision</button>
<button id="addFlow">+ Flow</button>
<button id="addEnd">+ End</button>
<button id="clearFlow">Limpiar Todo</button>

<div class="json-section">
<strong>JSON Output</strong>
<pre id="jsonView">{}</pre>
</div>
</aside>

<div class="canvas-wrap">
  <div id="canvas" style="width:100%;height:100%">
    <svg id="svg" width="3000" height="3000" style="position:absolute;left:0;top:0;pointer-events:none"></svg>
  </div>
</div>

<script>
class Box {
  constructor(flow, id, type, x=60, y=60, title='Nodo') {
    this.flow = flow; this.id = id; this.type = type; this.x = x; this.y = y; 
    this.w = 140; this.h = 70;
    this.title = title; this.key = `${type}_${id.split('_')[1]}`; // Inicializar key
    this.anchors = {};
    this.options = (type === 'decision' || type === 'questions') ? [] : null; // Array para decision y questions
    this.steps = (type === 'flow' || type === 'trigger') ? [] : null;
    if (this.type === 'trigger') {
      this.triggers = ['hola','hello'];
    }
    if (this.type === 'questions' || this.type === 'end') {
      this.question = '¿Qué desea?';
    }
    if (this.type === 'questions') {
      this.options = [
        { key: 'cafe', keywords: ['cafe', 'coffee', 'cafes'] },
        { key: 'latte', keywords: ['latte', 'latte coffee'] },
        { key: 'americano', keywords: ['americano', 'american coffee'] },
        { key: 'cappuccino', keywords: ['cappuccino', 'cappucino'] }
      ];
    }
    if (this.type === 'decision') {
      this.options = []; // Array de { flowId: string, keywords: array }
    }
    this.el = this._createElement();
    this._enableDrag(); this.updatePosition();
    if (this.type === 'decision') {
      const addBtn = this.el.querySelector('.add-branch');
      if (addBtn) addBtn.addEventListener('click', () => this.addBranch());
      this.renderBranches();
    }
    if (this.type === 'trigger') {
      const addBtn = this.el.querySelector('.add-trigger');
      if (addBtn) addBtn.addEventListener('click', () => this.addTrigger());
      const titleInput = this.el.querySelector('.title-input');
      if (titleInput) titleInput.addEventListener('input', e => { this.title = e.target.value; this.flow.updateJSON(); });
      const keyInput = this.el.querySelector('.key-input');
      if (keyInput) keyInput.addEventListener('input', e => { this.key = e.target.value; this.flow.updateJSON(); });
      this.renderTriggers();
    }
    if (this.type === 'questions' || this.type === 'end') {
      const qInput = this.el.querySelector('.question-text');
      if (qInput) qInput.addEventListener('input', e => { this.question = e.target.value; this.flow.updateJSON(); });
      const titleInput = this.el.querySelector('.title-input');
      if (titleInput) titleInput.addEventListener('input', e => { this.title = e.target.value; this.flow.updateJSON(); });
      const keyInput = this.el.querySelector('.key-input');
      if (keyInput) keyInput.addEventListener('input', e => { this.key = e.target.value; this.flow.updateJSON(); });
      if (this.type === 'questions') {
        const addOptBtn = this.el.querySelector('.add-qopt');
        if (addOptBtn) addOptBtn.addEventListener('click', () => this.addQuestionOptionObject());
        this.renderQuestionOptionsObject();
      }
    }
    if (this.type === 'decision' || this.type === 'flow') {
      const titleInput = this.el.querySelector('.title-input');
      if (titleInput) titleInput.addEventListener('input', e => { this.title = e.target.value; this.flow.updateJSON(); });
      const keyInput = this.el.querySelector('.key-input');
      if (keyInput) keyInput.addEventListener('input', e => { this.key = e.target.value; this.flow.updateJSON(); });
    }
    const delBoxBtn = this.el.querySelector('.del-box');
    if (delBoxBtn) delBoxBtn.addEventListener('click', () => this.flow.removeBox(this.id));
    this.addAnchors();
  }

  _createElement() {
    const el = document.createElement('div');
    el.className = `box ${this.type}`; el.dataset.id = this.id;
    let inner = `
      <div class="header">
        <button class="del-box">×</button>
        <input class="title-input" type="text" value="${this.title}">
        <input class="key-input" type="text" value="${this.key}" placeholder="Key">
      </div>
      <div class="body">
    `;
    if (this.type === 'trigger') {
      inner += `
        <div class="trigger-list"></div>
      `;
    } else if (this.type === 'questions' || this.type === 'end') {
      inner += `
        <div class="box-field">
          <label>Pregunta</label>
          <input class="question-text" type="text" value="${this.question}">
        </div>
      `;
      if (this.type === 'questions') {
        inner += `
          <div class="box-field">
            <label>Options (key → [keywords])</label>
            <div class="qopt-list"></div>
          </div>
        `;
      }
    } else if (this.type === 'decision') {
      inner += `
        <div class="box-field">
          <label>Options (flow_id → [keywords])</label>
          <div class="branches"></div>
        </div>
      `;
    }
    inner += `</div><div class="footer">`;
    if (this.type === 'trigger') {
      inner += `
        <button class="add-trigger">+ Palabra</button>
      `;
    } else if (this.type === 'questions') {
      inner += `
        <button class="add-qopt">+ Opción</button>
      `;
    } else if (this.type === 'decision') {
      inner += `
        <button class="add-branch">+ Opción</button>
      `;
    }
    inner += `
      <small>${this.type}</small>
    </div>
    `;
    el.innerHTML = inner;
    this.flow.stage.appendChild(el); return el;
  }

  addAnchors() {
    if (this.isInputAllowed('left')) this.addAnchor('left');
    if (this.isOutputAllowed('right')) this.addAnchor('right');
  }

  addAnchor(pos) {
    const anchor = document.createElement('div');
    anchor.className = 'anchor';
    anchor.dataset.pos = pos;
    anchor.dataset.box = this.id;
    this.el.appendChild(anchor);
    this.anchors[pos] = anchor;
  }

  addBranch() {
    if (this.type !== 'decision') return;
    let idx = this.options.length + 1;
    this.options.push({ flowId: `option${idx}`, keywords: [''] });
    this.renderBranches();
    const pos = `out${this.options.length - 1}`;
    if (!this.anchors[pos]) {
      this.addAnchor(pos);
    }
    this.repositionOutputs();
    this.h += 25;
    this.el.style.minHeight = `${this.h}px`;
    this.flow.requestUpdate();
    this.flow.updateJSON();
  }

  renderBranches() {
    if (this.type !== 'decision') return;
    const container = this.el.querySelector('.branches');
    if (!container) return;
    container.innerHTML = '';
    this.options.forEach((opt, index) => {
      const row = document.createElement('div');
      row.className = 'branch-row';
      row.dataset.index = index;
      row.innerHTML = `
        <input class="branch-input" readonly type="text" value="${opt.flowId}" placeholder="flow_id">
        <input class="branch-input" type="text" value="${opt.keywords.join(', ')}" placeholder="keywords (comma-separated)">
        <button class="del">×</button>
      `;
      const [flowIdInput, keywordsInput, delBtn] = row.querySelectorAll('input,button');
      keywordsInput.addEventListener('input', e => {
        opt.keywords = e.target.value.split(',').map(k => k.trim()).filter(k => k);
        this.flow.updateJSON();
      });
      delBtn.addEventListener('click', () => {
        const outgoingConn = [...this.flow.conns.values()].find(c => c.fromBox === this && c.fromAnchor === `out${index}`);
        if (outgoingConn) {
          outgoingConn.destroy();
          this.flow.conns.delete(outgoingConn.id);
        }
        this.options.splice(index, 1);

        Object.keys(this.anchors).filter(k => k.startsWith('out')).forEach(pos => {
          this.anchors[pos].remove();
          delete this.anchors[pos];
        });

        [...this.flow.conns.values()].filter(c => c.fromBox === this && c.fromAnchor.startsWith('out')).forEach(conn => {
          let anchorIndex = parseInt(conn.fromAnchor.replace('out', ''));
          if (anchorIndex > index) {
            conn.fromAnchor = `out${anchorIndex - 1}`;
          }
        });

        this.renderBranches();
        this.h = 70 + (this.options.length * 25);
        this.el.style.minHeight = `${this.h}px`;
        this.repositionOutputs();
        this.flow.requestUpdate();
        this.flow.updateJSON();
      });
      container.appendChild(row);

      const pos = `out${index}`;
      if (!this.anchors[pos]) {
        this.addAnchor(pos);
      }
    });
  }

  renderTriggers() {
    if (this.type !== 'trigger') return;
    const container = this.el.querySelector('.trigger-list');
    if (!container) return;
    container.innerHTML = '';
    this.triggers.forEach((word, index) => {
      const row = document.createElement('div');
      row.className = 'trigger-row';
      row.innerHTML = `
        <input class="trigger-input" type="text" value="${word}">
        <button class="del-trigger" data-index="${index}">×</button>
      `;
      const input = row.querySelector('.trigger-input');
      input.addEventListener('input', e => { this.triggers[index] = e.target.value; this.flow.updateJSON(); });
      const delBtn = row.querySelector('.del-trigger');
      delBtn.addEventListener('click', () => { this.removeTrigger(index); });
      container.appendChild(row);
    });
  }

  renderQuestionOptionsObject() {
    if (this.type !== 'questions') return;
    const container = this.el.querySelector('.qopt-list');
    if (!container) return;
    container.innerHTML = '';
    this.options.forEach((opt, index) => {
      const row = document.createElement('div');
      row.className = 'qopt-row';
      row.innerHTML = `
        <input class="qopt-input" type="text" value="${opt.key}" placeholder="key">
        <input class="qopt-input" type="text" value="${opt.keywords.join(', ')}" placeholder="keywords (comma-separated)">
        <button class="del-qopt">×</button>
      `;
      const [keyInput, keywordsInput, delBtn] = row.querySelectorAll('.qopt-input, .del-qopt');
      keyInput.addEventListener('input', e => {
        opt.key = e.target.value;
        this.flow.updateJSON();
      });
      keywordsInput.addEventListener('input', e => {
        opt.keywords = e.target.value.split(',').map(k => k.trim()).filter(k => k);
        this.flow.updateJSON();
      });
      delBtn.addEventListener('click', () => {
        this.options.splice(index, 1);
        this.renderQuestionOptionsObject();
        this.flow.updateJSON();
      });
      container.appendChild(row);
    });
  }

  addQuestionOptionObject() {
    if (this.type !== 'questions') return;
    let base = 'option';
    let idx = this.options.length + 1;
    this.options.push({ key: `${base}${idx}`, keywords: [''] });
    this.renderQuestionOptionsObject();
    this.flow.updateJSON();
  }

  addTrigger() {
    if (this.type !== 'trigger') return;
    this.triggers.push('');
    this.renderTriggers();
    this.h += 25;
    this.el.style.minHeight = `${this.h}px`;
    this.flow.requestUpdate();
    this.flow.updateJSON();
  }

  removeTrigger(index) {
    if (this.type !== 'trigger') return;
    this.triggers.splice(index, 1);
    this.renderTriggers();
    this.flow.requestUpdate();
    this.flow.updateJSON();
  }

  repositionOutputs() {
    if (this.type !== 'decision') return;
    const inputs = this.el.querySelectorAll('.branch-row');
    inputs.forEach((row, i) => {
      const pos = `out${i}`;
      const anchor = this.anchors[pos];
      if (anchor) {
        const inputRect = row.getBoundingClientRect();
        const containerRect = this.el.getBoundingClientRect();
        const relativeTop = inputRect.top - containerRect.top + inputRect.height / 2;
        anchor.style.right = '-4px';
        anchor.style.top = `${relativeTop}px`;
        anchor.style.transform = 'translateY(-50%)';
      }
    });
  }

  isInputAllowed(pos) {
    return this.type !== 'trigger' && pos === 'left';
  }

  isOutputAllowed(pos) {
    if (this.type === 'end') return false;
    if (this.type === 'decision') return pos.startsWith('out');
    return pos === 'right';
  }

  _enableDrag() {
    let startX, startY, origX, origY, dragging=false;
    this.el.addEventListener('mousedown', e => {
      if(e.target.classList.contains('anchor') || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
      dragging=true; startX=e.clientX; startY=e.clientY;
      origX=this.x; origY=this.y; e.preventDefault();
    });
    window.addEventListener('mousemove', e => {
      if(!dragging) return;
      this.x = origX + (e.clientX - startX);
      this.y = origY + (e.clientY - startY);
      this.updatePosition(); this.flow.requestUpdate();
    });
    window.addEventListener('mouseup', () => {
      if(dragging){ dragging=false; this.flow.updateJSON(); }
    });
  }

  getAnchorPos(pos) {
    const anchorEl = this.anchors[pos];
    if (!anchorEl || anchorEl.classList.contains('hidden')) return null;
    const rect = anchorEl.getBoundingClientRect();
    const canvasRect = this.flow.stage.getBoundingClientRect();
    return {
      x: rect.left + rect.width/2 - canvasRect.left,
      y: rect.top + rect.height/2 - canvasRect.top
    };
  }

  updatePosition() {
    this.el.style.transform = `translate(${this.x}px, ${this.y}px)`;
    this.repositionOutputs();
  }

  serialize() { 
    const base = {
      id: this.id, type: this.type, x: this.x, y: this.y,
      w: this.w, h: this.h, title: this.title, key: this.key
    };
    if (this.type === 'decision' || this.type === 'questions') {
      base.options = this.options.reduce((acc, opt) => {
        acc[this.type === 'decision' ? opt.flowId : opt.key] = opt.keywords;
        return acc;
      }, {});
    }
    if (this.type === 'trigger') {
      base.triggers = this.triggers;
      base.steps = this.steps;
    }
    if (this.type === 'questions' || this.type === 'end') {
      base.question = this.question;
    }
    if (this.type === 'flow') {
      base.steps = this.steps;
    }
    return base; 
  }

  destroy() { this.el.remove(); }
}

class Connector {
  constructor(flow, id, fromBox, fromAnchor, toBox, toAnchor) {
    this.flow = flow; this.id = id; this.fromBox = fromBox; this.fromAnchor = fromAnchor;
    this.toBox = toBox; this.toAnchor = toAnchor;
    this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    this.path.setAttribute('class', 'conn-line'); this.flow.svg.appendChild(this.path);
  }

  update() {
    const a = this.fromBox.getAnchorPos(this.fromAnchor);
    const b = this.toBox.getAnchorPos(this.toAnchor);
    if (a && b) {
      const offset = Math.abs(b.x - a.x) / 3;
      const d = `M ${a.x} ${a.y} C ${a.x + offset} ${a.y} ${b.x - offset} ${b.y} ${b.x} ${b.y}`;
      this.path.setAttribute('d', d);
    }
  }

  serialize() { 
    return {
      id: this.id, from: this.fromBox.id, fromAnchor: this.fromAnchor, 
      to: this.toBox.id, toAnchor: this.toAnchor
    }; 
  }

  destroy() { this.path.remove(); }
}

const rules = {
  trigger: ['questions'],
  questions: ['questions', 'decision', 'end'],
  decision: ['flow'],
  flow: ['questions', 'end'],
  end: []
};

const entradas = {
  trigger: { max: 0, permitidos: {} },
  questions: { max: Infinity, permitidos: { flow: 1, questions: Infinity, trigger: 1 } },
  decision: { max: Infinity, permitidos: { questions: Infinity } },
  flow: { max: Infinity, permitidos: { decision: Infinity } },
  end: { max: Infinity, permitidos: { flow: Infinity, questions: Infinity, decision: Infinity } }
};

class Flowchart {
  constructor() {
    this.stage = document.getElementById('canvas'); 
    this.svg = document.getElementById('svg');
    this.boxes = new Map(); 
    this.conns = new Map(); 
    this.boxCounter = 0; 
    this.connCounter = 0;
    this.pendingAnchor = null; 
    this._needsUpdate = false; 
    this._bindEvents();
  }

  _bindEvents() {
    document.getElementById('addTrigger').addEventListener('click', () => this.addBox('trigger'));
    document.getElementById('addQuestions').addEventListener('click', () => this.addBox('questions'));
    document.getElementById('addDecision').addEventListener('click', () => this.addBox('decision'));
    document.getElementById('addFlow').addEventListener('click', () => this.addBox('flow'));
    document.getElementById('addEnd').addEventListener('click', () => this.addBox('end'));
    document.getElementById('clearFlow').addEventListener('click', () => this.clear());

    this.stage.addEventListener('click', e => {
      const anchor = e.target.closest('.anchor:not(.hidden)');
      if (anchor) {
        const box = this.boxes.get(anchor.dataset.box);
        const pos = anchor.dataset.pos;

        if (this.pendingAnchor) {
          for (const conn of this.conns.values()) {
            if ((conn.fromBox === this.pendingAnchor.box && conn.toBox === box) || 
                (conn.fromBox === box && conn.toBox === this.pendingAnchor.box)) {
              this.pendingAnchor.el.classList.remove('active-anchor');
              this.pendingAnchor = null;
              return;
            }
          }
        }

        if (this.pendingAnchor && this.pendingAnchor.box === box && this.pendingAnchor.pos === pos) {
          this.pendingAnchor.el.classList.remove('active-anchor');
          this.pendingAnchor = null;
          return;
        }

        if (this.pendingAnchor && this.pendingAnchor.el) this.pendingAnchor.el.classList.remove('active-anchor');

        anchor.classList.add('active-anchor');

        if (this.pendingAnchor) {
          this.createConn(this.pendingAnchor.box, this.pendingAnchor.pos, box, pos);
          this.pendingAnchor.el.classList.remove('active-anchor');
          anchor.classList.remove('active-anchor');
          this.pendingAnchor = null;
        } else {
          this.pendingAnchor = { box, pos, el: anchor };
        }
        return;
      }

      if (this.pendingAnchor) {
        this.pendingAnchor.el.classList.remove('active-anchor');
        this.pendingAnchor = null;
      }
    });
  }

  addBox(type, x=60, y=60) {
    if (type === 'trigger' && Array.from(this.boxes.values()).some(b => b.type === 'trigger')) {
      return;
    }
    const prefixMap = { trigger: 'trigger', questions: 'question', decision: 'decision', flow: 'flow', end: 'end' };
    const prefix = prefixMap[type] || type;
    const id = `${prefix}_${Date.now()}`;
    const title = `${type.charAt(0).toUpperCase() + type.slice(1)} ${this.boxCounter + 1}`;
 
    const box = new Box(this, id, type, x, y, title);
    this.boxes.set(id, box); 
    this.boxCounter++;
    this.updateJSON(); 
    return box;
  }

  removeBox(id) {
    const box = this.boxes.get(id);
    if (!box) return;

    [...this.conns.values()].forEach(conn => {
      if (conn.fromBox === box || conn.toBox === box) {
        conn.destroy();
        this.conns.delete(conn.id);
        if (conn.fromBox.type === 'decision' && conn.toBox === box) {
          const index = parseInt(conn.fromAnchor.replace('out', ''));
          if (conn.fromBox.options[index] && conn.fromBox.options[index].flowId === box.id) {
            conn.fromBox.options[index].flowId = `option${index + 1}`;
            conn.fromBox.renderBranches();
          }
        }
      }
    });

    box.destroy();
    this.boxes.delete(id);
    this.requestUpdate();
    this.updateJSON();
  }

  hasFlowBetween(fromBox, toBox) {
    const visited = new Set();
    const stack = [fromBox];
    while (stack.length) {
      const box = stack.pop();
      if (box === toBox) return true;
      visited.add(box);
      for (const conn of this.conns.values()) {
        if (conn.fromBox === box && !visited.has(conn.toBox)) {
          stack.push(conn.toBox);
        }
      }
    }
    return false;
  }

  createConn(fromBox, fromAnchor, toBox, toAnchor) {
    if (fromBox === toBox) return;

    if (!fromBox.isOutputAllowed(fromAnchor) || !toBox.isInputAllowed(toAnchor)) return;

    if (!rules[fromBox.type] || !rules[fromBox.type].includes(toBox.type)) return;

    const reglaEntrada = entradas[toBox.type];
    if (!reglaEntrada) return;

    const maxPorTipo = reglaEntrada.permitidos[fromBox.type];
    if (maxPorTipo === undefined) return;

    const count = Array.from(this.conns.values()).filter(c => c.toBox === toBox && c.fromBox.type === fromBox.type).length;
    if (count >= maxPorTipo) return;

    if (this.hasFlowBetween(fromBox, toBox)) return;

    if (toBox.type === 'end' && this.yaAlcanzaEnd(fromBox, toBox)) return;

    const id = `c${++this.connCounter}`;
    const conn = new Connector(this, id, fromBox, fromAnchor, toBox, toAnchor);
    this.conns.set(id, conn);

    if (fromBox.type === 'decision' && toBox.type === 'flow') {
      const index = parseInt(fromAnchor.replace('out', ''));
      if (fromBox.options[index]) {
        fromBox.options[index].flowId = toBox.id;
        fromBox.renderBranches();
        fromBox.repositionOutputs();
        this.updateJSON();
      }
    }

    if (fromBox.type === 'trigger' || fromBox.type === 'flow') {
      const steps = fromBox.steps;
      let stepCounter = steps.length > 0 ? steps[steps.length - 1].step + 1 : 1;
      if (toBox.type === 'decision') {
        steps.push({ step: stepCounter, ...toBox.serialize() });
      } else if (toBox.type === 'questions' || toBox.type === 'end') {
        steps.push({ step: stepCounter, ...toBox.serialize() });
      }
    }

    this.requestUpdate();
    this.updateJSON();
    return conn;
  }

  yaAlcanzaEnd(fromBox, endBox) {
    return this.hasFlowBetween(fromBox, endBox);
  }

  requestUpdate() {
    if (this._needsUpdate) return;
    this._needsUpdate = true;
    requestAnimationFrame(() => {
      this._needsUpdate = false;
      this._render();
    });
  }

  _render() {
    for (const c of this.conns.values()) c.update();
  }

  updateJSON() {
    const stepsMap = new Map();
    this.boxes.forEach(box => {
      if (box.type === 'trigger' || box.type === 'flow') {
        stepsMap.set(box.id, []);
      }
    });

    this.boxes.forEach(triggerBox => {
      if (triggerBox.type !== 'trigger') return;
      const steps = [];
      let currentBox = triggerBox;
      let stepCounter = 1;
      const visited = new Set();

      while (currentBox) {
        visited.add(currentBox.id);
        const nextConn = [...this.conns.values()].find(c => c.fromBox === currentBox && 
          (c.toBox.type === 'questions' || c.toBox.type === 'decision' || c.toBox.type === 'end'));
        if (!nextConn) break;
        const nextBox = nextConn.toBox;
        steps.push({ step: stepCounter++, ...nextBox.serialize() });
        if (nextBox.type === 'decision') break;
        currentBox = nextBox;
      }

      stepsMap.set(triggerBox.id, steps);
    });

    this.boxes.forEach(flowBox => {
      if (flowBox.type !== 'flow') return;
      const steps = [];
      let currentBox = flowBox;
      let stepCounter = 1;
      const visited = new Set();

      while (currentBox) {
        visited.add(currentBox.id);
        const nextConn = [...this.conns.values()].find(c => c.fromBox === currentBox && 
          (c.toBox.type === 'questions' || c.toBox.type === 'end'));
        if (!nextConn) break;
        const nextBox = nextConn.toBox;
        steps.push({ step: stepCounter++, ...nextBox.serialize() });
        currentBox = nextBox;
      }

      stepsMap.set(flowBox.id, steps);
    });

    this.boxes.forEach(box => {
      if (box.type === 'trigger' || box.type === 'flow') {
        box.steps = stepsMap.get(box.id) || [];
      }
    });

    const allStepIds = new Set();
    stepsMap.forEach(steps => {
      steps.forEach(step => allStepIds.add(step.id));
    });

    const data = {
      boxes: [...this.boxes.values()]
        .filter(b => !allStepIds.has(b.id) || b.type === 'trigger' || b.type === 'flow' || b.type === 'decision')
        .map(b => b.serialize()),
      conns: [...this.conns.values()].map(c => c.serialize())
    };

    document.getElementById('jsonView').textContent = JSON.stringify(data, null, 2);
  }

  clear() {
    for (const b of this.boxes.values()) b.destroy();
    this.boxes.clear();
    for (const c of this.conns.values()) c.destroy();
    this.conns.clear();
    this.boxCounter = 0;
    this.connCounter = 0;
    this.updateJSON();
  }

  loadJSON(jsonData) {
  // Limpiar el estado actual
  this.clear();

  // Primero cargar todos los nodos de boxes, incluyendo los de steps
  const allBoxes = new Map();
  jsonData.boxes.forEach(boxData => {
    const box = new Box(this, boxData.id, boxData.type, boxData.x, boxData.y, boxData.title);
    box.w = boxData.w;
    box.h = boxData.h;
    box.key = boxData.key;

    if (box.type === 'trigger') {
      box.triggers = boxData.triggers || [];
      box.steps = boxData.steps || [];
    }
    if (box.type === 'questions' || box.type === 'end') {
      box.question = boxData.question || '';
    }
    if (box.type === 'decision' || box.type === 'questions') {
      box.options = Object.entries(boxData.options || {}).map(([key, keywords]) => {
        return box.type === 'decision' ? { flowId: key, keywords } : { key, keywords };
      });
    }
    if (box.type === 'flow') {
      box.steps = boxData.steps || [];
    }

    // Renderizar contenido específico según el tipo
    if (box.type === 'decision') box.renderBranches();
    if (box.type === 'trigger') box.renderTriggers();
    if (box.type === 'questions') box.renderQuestionOptionsObject();

    allBoxes.set(box.id, box);
    this.boxes.set(box.id, box);
    this.boxCounter = Math.max(this.boxCounter, parseInt(box.id.split('_')[1]) || 0);
  });

  // Procesar steps anidados para crear nodos adicionales
  jsonData.boxes.forEach(boxData => {
    if (boxData.steps && (boxData.type === 'trigger' || boxData.type === 'flow')) {
      boxData.steps.forEach(step => {
        if (!allBoxes.has(step.id)) {
          const stepBox = new Box(this, step.id, step.type, step.x, step.y, step.title);
          stepBox.w = step.w;
          stepBox.h = step.h;
          stepBox.key = step.key;
          if (step.type === 'questions' || step.type === 'end') {
            stepBox.question = step.question || '';
          }
          if (step.type === 'decision' || step.type === 'questions') {
            stepBox.options = Object.entries(step.options || {}).map(([key, keywords]) => {
              return step.type === 'decision' ? { flowId: key, keywords } : { key, keywords };
            });
          }
          if (step.type === 'decision') stepBox.renderBranches();
          if (step.type === 'questions') stepBox.renderQuestionOptionsObject();
          allBoxes.set(step.id, stepBox);
          this.boxes.set(step.id, stepBox);
          this.boxCounter = Math.max(this.boxCounter, parseInt(step.id.split('_')[1]) || 0);
        }
      });
    }
  });

  // Cargar las conexiones explícitas
  jsonData.conns.forEach(connData => {
    const fromBox = this.boxes.get(connData.from);
    const toBox = this.boxes.get(connData.to);
    if (fromBox && toBox) {
      const conn = new Connector(this, connData.id, fromBox, connData.fromAnchor, toBox, connData.toAnchor);
      this.conns.set(conn.id, conn);
      this.connCounter = Math.max(this.connCounter, parseInt(conn.id.replace('c', '')) || 0);
    }
  });

  // Generar conexiones automáticas a partir de steps en trigger y flow
  jsonData.boxes.forEach(boxData => {
    if (boxData.steps && (boxData.type === 'trigger' || boxData.type === 'flow')) {
      const parentBox = this.boxes.get(boxData.id);
      if (boxData.steps.length > 0) {
        // Conectar el nodo padre (trigger o flow) con su primer step
        const firstStep = this.boxes.get(boxData.steps[0].id);
        if (parentBox && firstStep && !this.conns.has(`c${this.connCounter + 1}`)) {
          const connId = `c${++this.connCounter}`;
          const conn = new Connector(this, connId, parentBox, 'right', firstStep, 'left');
          this.conns.set(connId, conn);
        }

        // Conectar los steps consecutivos
        boxData.steps.forEach((step, index) => {
          const currentBox = this.boxes.get(step.id);
          if (index < boxData.steps.length - 1) {
            const nextStep = boxData.steps[index + 1];
            const nextBox = this.boxes.get(nextStep.id);
            if (currentBox && nextBox && !this.conns.has(`c${this.connCounter + 1}`)) {
              const connId = `c${++this.connCounter}`;
              const conn = new Connector(this, connId, currentBox, 'right', nextBox, 'left');
              this.conns.set(connId, conn);
            }
          }
        });
      }
    }
  });

  // Actualizar el JSON y renderizar
  this.requestUpdate();
  this.updateJSON();
}
}
const sampleJSON = {
  "boxes": [
    {
      "id": "trigger_1",
      "type": "trigger",
      "x": 60,
      "y": 60,
      "w": 140,
      "h": 70,
      "title": "Trigger Inicio",
      "key": "trigger_1",
      "triggers": ["hola", "buenas"],
      "steps": [
        {
          "step": 1,
          "id": "question_name",
          "type": "questions",
          "x": 300,
          "y": 60,
          "w": 180,
          "h": 70,
          "title": "Pregunta Nombre",
          "key": "question_name",
          "question": "¿Cuál es tu nombre?"
        },
        {
          "step": 2,
          "id": "question_menu",
          "type": "questions",
          "x": 600,
          "y": 60,
          "w": 200,
          "h": 70,
          "title": "Pregunta Menú",
          "key": "question_menu",
          "question": "Ok {nombre}, tenemos Pizza, Hamburguesa, Sopas y Tacos. ¿Qué deseas?",
          "options": {
            "pizza": ["pizza", "pizzas"],
            "hamburguesa": ["hamburguesa", "burger"],
            "sopa": ["sopa", "sopas"],
            "tacos": ["taco", "tacos"]
          }
        },
        {
          "step": 3,
          "id": "decision_menu",
          "type": "decision",
          "x": 950,
          "y": 60,
          "w": 180,
          "h": 200,
          "title": "Decision Menú",
          "key": "decision_menu",
          "options": {
            "flow_pizza": ["pizza"],
            "flow_hamburguesa": ["hamburguesa"],
            "flow_sopa": ["sopa"],
            "flow_tacos": ["tacos"]
          }
        }
      ]
    },
    {
      "id": "flow_pizza",
      "type": "flow",
      "x": 1300,
      "y": 40,
      "w": 160,
      "h": 70,
      "title": "Flow Pizza",
      "key": "flow_pizza",
      "steps": [
        {
          "step": 1,
          "id": "question_pizza_size",
          "type": "questions",
          "x": 1550,
          "y": 40,
          "w": 200,
          "h": 70,
          "title": "Tamaño Pizza",
          "key": "question_pizza_size",
          "question": "¿Qué tamaño de pizza deseas?",
          "options": {
            "pequeña": ["pequeña", "chica"],
            "mediana": ["mediana"],
            "grande": ["grande"]
          }
        },
        {
          "step": 2,
          "id": "question_pizza_type",
          "type": "questions",
          "x": 1850,
          "y": 40,
          "w": 200,
          "h": 70,
          "title": "Tipo Pizza",
          "key": "question_pizza_type",
          "question": "¿Qué tipo de pizza deseas?",
          "options": {
            "hawaiana": ["hawaiana"],
            "pepperoni": ["pepperoni"],
            "queso": ["queso", "margarita"]
          }
        },
        {
          "step": 3,
          "id": "end_pizza",
          "type": "end",
          "x": 2150,
          "y": 40,
          "w": 140,
          "h": 70,
          "title": "Fin Pizza",
          "key": "end_pizza",
          "question": "¡Perfecto! Tu pizza está en preparación 🍕"
        }
      ]
    },
    {
      "id": "flow_hamburguesa",
      "type": "flow",
      "x": 1300,
      "y": 200,
      "w": 180,
      "h": 70,
      "title": "Flow Hamburguesa",
      "key": "flow_hamburguesa",
      "steps": [
        {
          "step": 1,
          "id": "question_burger_type",
          "type": "questions",
          "x": 1550,
          "y": 200,
          "w": 220,
          "h": 70,
          "title": "Tipo Hamburguesa",
          "key": "question_burger_type",
          "question": "¿Qué tipo de hamburguesa deseas?",
          "options": {
            "clasica": ["clásica", "sencilla"],
            "doble": ["doble", "extra carne"],
            "pollo": ["pollo"]
          }
        },
        {
          "step": 2,
          "id": "question_burger_side",
          "type": "questions",
          "x": 1850,
          "y": 200,
          "w": 220,
          "h": 70,
          "title": "Acompañamiento",
          "key": "question_burger_side",
          "question": "¿Quieres papas fritas o ensalada como acompañamiento?",
          "options": {
            "papas": ["papas", "fritas"],
            "ensalada": ["ensalada"],
            "ninguno": ["ninguno", "no"]
          }
        },
        {
          "step": 3,
          "id": "end_hamburguesa",
          "type": "end",
          "x": 2150,
          "y": 200,
          "w": 200,
          "h": 70,
          "title": "Fin Hamburguesa",
          "key": "end_hamburguesa",
          "question": "¡Excelente! Tu hamburguesa estará lista 🍔"
        }
      ]
    },
    {
      "id": "flow_sopa",
      "type": "flow",
      "x": 1300,
      "y": 360,
      "w": 160,
      "h": 70,
      "title": "Flow Sopas",
      "key": "flow_sopa",
      "steps": [
        {
          "step": 1,
          "id": "question_soup_type",
          "type": "questions",
          "x": 1550,
          "y": 360,
          "w": 220,
          "h": 70,
          "title": "Tipo Sopa",
          "key": "question_soup_type",
          "question": "¿Qué tipo de sopa deseas?",
          "options": {
            "pollo": ["pollo"],
            "res": ["res", "carne"],
            "vegetales": ["vegetales", "verduras"]
          }
        },
        {
          "step": 2,
          "id": "question_soup_size",
          "type": "questions",
          "x": 1850,
          "y": 360,
          "w": 220,
          "h": 70,
          "title": "Tamaño Sopa",
          "key": "question_soup_size",
          "question": "¿Qué tamaño deseas?",
          "options": {
            "pequeña": ["pequeña", "chica"],
            "grande": ["grande"]
          }
        },
        {
          "step": 3,
          "id": "end_sopa",
          "type": "end",
          "x": 2150,
          "y": 360,
          "w": 200,
          "h": 70,
          "title": "Fin Sopa",
          "key": "end_sopa",
          "question": "¡Genial! Tu sopa estará lista 🍲"
        }
      ]
    },
    {
      "id": "flow_tacos",
      "type": "flow",
      "x": 1300,
      "y": 520,
      "w": 160,
      "h": 70,
      "title": "Flow Tacos",
      "key": "flow_tacos",
      "steps": [
        {
          "step": 1,
          "id": "question_taco_type",
          "type": "questions",
          "x": 1550,
          "y": 520,
          "w": 220,
          "h": 70,
          "title": "Tipo Taco",
          "key": "question_taco_type",
          "question": "¿Qué tipo de tacos deseas?",
          "options": {
            "pastor": ["al pastor"],
            "pollo": ["pollo"],
            "res": ["res", "carne"]
          }
        },
        {
          "step": 2,
          "id": "question_taco_quantity",
          "type": "questions",
          "x": 1850,
          "y": 520,
          "w": 220,
          "h": 70,
          "title": "Cantidad Tacos",
          "key": "question_taco_quantity",
          "question": "¿Cuántos tacos quieres?",
          "options": {
            "2": ["2", "dos"],
            "3": ["3", "tres"],
            "5": ["5", "cinco"]
          }
        },
        {
          "step": 3,
          "id": "end_tacos",
          "type": "end",
          "x": 2150,
          "y": 520,
          "w": 200,
          "h": 70,
          "title": "Fin Tacos",
          "key": "end_tacos",
          "question": "¡Listo! Tus tacos estarán en camino 🌮"
        }
      ]
    }
  ],
  "conns": [
    { "id": "c1", "from": "trigger_1", "fromAnchor": "right", "to": "question_name", "toAnchor": "left" },
    { "id": "c2", "from": "question_name", "fromAnchor": "right", "to": "question_menu", "toAnchor": "left" },
    { "id": "c3", "from": "question_menu", "fromAnchor": "right", "to": "decision_menu", "toAnchor": "left" },
    { "id": "c4", "from": "decision_menu", "fromAnchor": "out0", "to": "flow_pizza", "toAnchor": "left" },
    { "id": "c5", "from": "decision_menu", "fromAnchor": "out1", "to": "flow_hamburguesa", "toAnchor": "left" },
    { "id": "c6", "from": "decision_menu", "fromAnchor": "out2", "to": "flow_sopa", "toAnchor": "left" },
    { "id": "c7", "from": "decision_menu", "fromAnchor": "out3", "to": "flow_tacos", "toAnchor": "left" }
  ]
};

const FLOW = new Flowchart();
FLOW.loadJSON(sampleJSON);
</script>
</body>
</html>