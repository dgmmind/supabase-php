<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flowchart Minimalista</title>
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
  display: flex; 
  height: 100vh; 
  background: #fafafa;
  color: #333;
}

.sidebar { 
  width: 240px; 
  padding: 20px; 
  background: #fff;
  border-right: 1px solid #e5e5e5;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 600;
  color: #111;
}

button {
  padding: 8px 12px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
}

button:hover {
  background: #f8f8f8;
  border-color: #ccc;
}

button:active {
  transform: translateY(1px);
}

#clearFlow {
  background: #f5f5f5;
  color: #666;
  margin-top: 8px;
}

#clearFlow:hover {
  background: #eee;
}

.canvas-wrap { 
  flex: 1; 
  position: relative; 
  background: #fafafa;
}

.box { 
  position: absolute; 
  width: 140px; 
  min-height: 70px; 
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  cursor: move; 
  padding: 12px;
  font-size: 12px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: box-shadow 0.15s ease;
}

.box:hover {
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.box strong {
  font-size: 13px;
  font-weight: 600;
  display: block;
  margin-bottom: 4px;
}

.box small {
  color: #666;
  font-size: 11px;
}

.box.trigger { border-left: 3px solid #10b981; }
.box.questions { border-left: 3px solid #3b82f6; }
.box.decision { border-left: 3px solid #f59e0b; }
.box.flow { border-left: 3px solid #8b5cf6; }
.box.end { border-left: 3px solid #ef4444; }

.anchor { 
  width: 6px; 
  height: 6px; 
  border: 1px solid #999; 
  border-radius: 50%; 
  position: absolute; 
  background: #fff;
  transition: all 0.15s ease;
}

.anchor:hover {
  width: 8px;
  height: 8px;
  border-color: #666;
  background: #f0f0f0;
}

.anchor[data-pos="left"] { 
  left: -4px; 
  top: 50%; 
  transform: translateY(-50%); 
}

.anchor[data-pos="right"] { 
  right: -4px; 
  top: 50%; 
  transform: translateY(-50%); 
}

.anchor.active-anchor {
  border-color: #3b82f6;
  background: #3b82f6;
  width: 8px;
  height: 8px;
}

.conn-line { 
  stroke: #666; 
  stroke-width: 1.5; 
  fill: none;
  opacity: 0.8;
}

.json-section {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #e5e5e5;
}

.json-section strong {
  font-size: 12px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

pre { 
  font-size: 10px; 
  background: #f8f8f8; 
  padding: 12px; 
  border-radius: 6px;
  max-height: 200px; 
  overflow: auto;
  margin: 8px 0 0 0;
  border: 1px solid #e5e5e5;
  color: #555;
}

.anchor.hidden { display: none; }

.branches {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin: 8px 0;
}

.branches input { 
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.branches input:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.add-branch {
  font-size: 10px !important;
  padding: 4px 8px !important;
  margin-top: 4px;
  background: #f8f8f8 !important;
  color: #666 !important;
  border: 1px solid #e5e5e5 !important;
}

.add-branch:hover {
  background: #eee !important;
}

/* Added styles for enhanced properties */
.box-field {
  margin: 4px 0;
}

.box-field label {
  font-size: 10px;
  color: #666;
  display: block;
  margin-bottom: 2px;
}

.box-field input, .box-field textarea {
  width: 100%;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: #fafafa;
}

.box-field input:focus, .box-field textarea:focus {
  outline: none;
  border-color: #3b82f6;
  background: #fff;
}

.trigger-words, .question-options, .decision-options {
  margin: 6px 0;
}

.word-item, .option-item {
  display: flex;
  align-items: center;
  gap: 4px;
  margin: 2px 0;
}

.word-item input, .option-item input {
  flex: 1;
  margin: 0;
}

.remove-btn {
  padding: 2px 6px !important;
  font-size: 10px !important;
  background: #fee2e2 !important;
  color: #dc2626 !important;
  border: 1px solid #fecaca !important;
}

.remove-btn:hover {
  background: #fecaca !important;
}

.decision-group {
  border: 1px solid #e5e5e5;
  border-radius: 4px;
  padding: 6px;
  margin: 4px 0;
  background: #fafafa;
}

.decision-group-header {
  font-size: 10px;
  color: #666;
  margin-bottom: 4px;
}
</style>
</head>
<body>
<aside class="sidebar">
<h3>Flowchart</h3>
<button id="addTrigger">+ Trigger</button>
<button id="addQuestions">+ Questions</button>
<button id="addDecision">+ Decision</button>
<button id="addFlow">+ Flow</button>
<button id="addEnd">+ End</button>
<button id="clearFlow">Limpiar Todo</button>

<div class="json-section">
<strong>JSON Output</strong>
<pre id="jsonView">{}</pre>
</div>
</aside>

<div class="canvas-wrap">
  <div id="canvas" style="width:100%;height:100%">
    <svg id="svg" width="3000" height="3000" style="position:absolute;left:0;top:0;pointer-events:none"></svg>
  </div>
</div>

<script>
class Box {
  constructor(flow, id, type, x=60, y=60, title='Nodo') {
    this.flow = flow; 
    this.id = id; 
    this.type = type; 
    this.x = x; 
    this.y = y; 
    this.w = 140; 
    this.h = 70;
    this.title = title; 
    this.anchors = {}; 
    
    this.key = `${type}_key_${id}`;
    
    if (type === 'trigger') {
      this.trigger = ['hola', 'hello'];
      this.childNodes = [];
    } else if (type === 'questions') {
      this.question = '¿Cuál es su nombre?';
      this.options = ['Opción 1', 'Opción 2'];
    } else if (type === 'decision') {
      this.options = {}; // Object with flow IDs as keys
    } else if (type === 'flow') {
      this.childNodes = [];
    }
    
    this.el = this._createElement();
    this._enableDrag(); 
    this.updatePosition();
    this.addAnchors();
    this._bindEvents();
  }

  _createElement() {
    const el = document.createElement('div');
    el.className = `box ${this.type}`; 
    el.dataset.id = this.id;
    
    let inner = `
      <strong>${this.title}</strong>
      <small>${this.type}</small>
      <div class="box-field">
        <label>Key:</label>
        <input type="text" value="${this.key}" data-field="key">
      </div>
    `;
    
    if (this.type === 'trigger') {
      inner += `
        <div class="trigger-words">
          <label style="font-size: 10px; color: #666;">Trigger words:</label>
          <div class="trigger-list"></div>
          <button class="add-branch">+ Palabra</button>
        </div>
      `;
    } else if (this.type === 'questions') {
      inner += `
        <div class="box-field">
          <label>Pregunta:</label>
          <textarea data-field="question" style="height: 40px;">${this.question}</textarea>
        </div>
        <div class="question-options">
          <label style="font-size: 10px; color: #666;">Opciones:</label>
          <div class="options-list"></div>
          <button class="add-branch">+ Opción</button>
        </div>
      `;
    } else if (this.type === 'decision') {
      inner += `
        <div class="decision-options">
          <label style="font-size: 10px; color: #666;">Opciones de decisión:</label>
          <div class="decision-list"></div>
          <button class="add-branch">+ Opción</button>
        </div>
      `;
    }
    
    el.innerHTML = inner;
    this.flow.stage.appendChild(el); 
    
    this.el = el;
    
    this._renderContent();
    
    return el;
  }

  _renderContent() {
    if (this.type === 'trigger') {
      this._renderTriggerWords();
    } else if (this.type === 'questions') {
      this._renderQuestionOptions();
    } else if (this.type === 'decision') {
      this._renderDecisionOptions();
    }
  }

  _renderTriggerWords() {
    const container = this.el.querySelector('.trigger-list');
    if (!container) return;
    
    container.innerHTML = '';
    this.trigger.forEach((word, index) => {
      const div = document.createElement('div');
      div.className = 'word-item';
      div.innerHTML = `
        <input type="text" value="${word}" data-trigger-index="${index}">
        <button class="remove-btn" onclick="this.closest('.box').boxRef.removeTriggerWord(${index})">×</button>
      `;
      container.appendChild(div);
      
      const input = div.querySelector('input');
      input.addEventListener('input', (e) => {
        this.trigger[index] = e.target.value;
        this.flow.updateJSON();
      });
    });
    
    this.el.boxRef = this;
  }

  _renderQuestionOptions() {
    const container = this.el.querySelector('.options-list');
    if (!container) return;
    
    container.innerHTML = '';
    this.options.forEach((option, index) => {
      const div = document.createElement('div');
      div.className = 'option-item';
      div.innerHTML = `
        <input type="text" value="${option}" data-option-index="${index}">
        <button class="remove-btn" onclick="this.closest('.box').boxRef.removeQuestionOption(${index})">×</button>
      `;
      container.appendChild(div);
      
      const input = div.querySelector('input');
      input.addEventListener('input', (e) => {
        this.options[index] = e.target.value;
        this.flow.updateJSON();
      });
    });
    
    this.el.boxRef = this;
  }

  _renderDecisionOptions() {
    const container = this.el.querySelector('.decision-list');
    if (!container) return;
    
    container.innerHTML = '';
    Object.keys(this.options).forEach((flowId) => {
      const div = document.createElement('div');
      div.className = 'decision-group';
      div.innerHTML = `
        <div class="decision-group-header">Flow ID: ${flowId}</div>
        <div class="keywords-${flowId}"></div>
        <button class="add-branch" onclick="this.closest('.box').boxRef.addKeyword('${flowId}')">+ Palabra</button>
        <button class="remove-btn" onclick="this.closest('.box').boxRef.removeDecisionOption('${flowId}')">× Eliminar</button>
      `;
      container.appendChild(div);
      
      this._renderKeywords(flowId);
    });
    
    this.el.boxRef = this;
  }

  _renderKeywords(flowId) {
    const container = this.el.querySelector(`.keywords-${flowId}`);
    if (!container) return;
    
    container.innerHTML = '';
    this.options[flowId].forEach((keyword, index) => {
      const div = document.createElement('div');
      div.className = 'word-item';
      div.innerHTML = `
        <input type="text" value="${keyword}" style="font-size: 10px;">
        <button class="remove-btn" onclick="this.closest('.box').boxRef.removeKeyword('${flowId}', ${index})">×</button>
      `;
      container.appendChild(div);
      
      const input = div.querySelector('input');
      input.addEventListener('input', (e) => {
        this.options[flowId][index] = e.target.value;
        this.flow.updateJSON();
      });
    });
  }

  _bindEvents() {
    // Key field
    const keyInput = this.el.querySelector('[data-field="key"]');
    if (keyInput) {
      keyInput.addEventListener('input', (e) => {
        this.key = e.target.value;
        this.flow.updateJSON();
      });
    }
    
    // Question field
    const questionInput = this.el.querySelector('[data-field="question"]');
    if (questionInput) {
      questionInput.addEventListener('input', (e) => {
        this.question = e.target.value;
        this.flow.updateJSON();
      });
    }
    
    // Add buttons
    const addBtn = this.el.querySelector('.add-branch');
    if (addBtn) {
      addBtn.addEventListener('click', () => {
        if (this.type === 'trigger') {
          this.addTriggerWord();
        } else if (this.type === 'questions') {
          this.addQuestionOption();
        } else if (this.type === 'decision') {
          this.addDecisionOption();
        }
      });
    }
  }

  addTriggerWord() {
    this.trigger.push('nueva_palabra');
    this._renderTriggerWords();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  removeTriggerWord(index) {
    this.trigger.splice(index, 1);
    this._renderTriggerWords();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  addQuestionOption() {
    this.options.push(`Opción ${this.options.length + 1}`);
    this._renderQuestionOptions();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  removeQuestionOption(index) {
    this.options.splice(index, 1);
    this._renderQuestionOptions();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  addDecisionOption() {
    const flowId = `flow_${Date.now()}`;
    this.options[flowId] = ['palabra_clave'];
    this._renderDecisionOptions();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  removeDecisionOption(flowId) {
    delete this.options[flowId];
    this._renderDecisionOptions();
    this._adjustHeight();
    this.flow.updateJSON();
  }

  addKeyword(flowId) {
    this.options[flowId].push('nueva_palabra');
    this._renderKeywords(flowId);
    this.flow.updateJSON();
  }

  removeKeyword(flowId, index) {
    this.options[flowId].splice(index, 1);
    this._renderKeywords(flowId);
    this.flow.updateJSON();
  }

  _adjustHeight() {
    const contentHeight = this.el.scrollHeight;
    this.h = Math.max(70, contentHeight + 10);
    this.el.style.minHeight = `${this.h}px`;
    this.flow.requestUpdate();
  }

  addAnchors() {
    if (this.isInputAllowed('left')) this.addAnchor('left');
    if (this.isOutputAllowed('right')) this.addAnchor('right');
  }

  addAnchor(pos) {
    const anchor = document.createElement('div');
    anchor.className = 'anchor';
    anchor.dataset.pos = pos;
    anchor.dataset.box = this.id;
    this.el.appendChild(anchor);
    this.anchors[pos] = anchor;
  }

  isInputAllowed(pos) {
    return this.type !== 'trigger' && pos === 'left';
  }

  isOutputAllowed(pos) {
    if (this.type === 'end') return false;
    return pos === 'right';
  }

  _enableDrag() {
    let startX, startY, origX, origY, dragging=false;
    this.el.addEventListener('mousedown', e => {
      if(e.target.classList.contains('anchor') || e.target.tagName === 'INPUT' || 
         e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
      dragging=true; startX=e.clientX; startY=e.clientY;
      origX=this.x; origY=this.y; e.preventDefault();
    });
    window.addEventListener('mousemove', e => {
      if(!dragging) return;
      this.x = origX + (e.clientX - startX);
      this.y = origY + (e.clientY - startY);
      this.updatePosition(); this.flow.requestUpdate();
    });
    window.addEventListener('mouseup', () => {
      if(dragging){ dragging=false; this.flow.updateJSON(); }
    });
  }

  getAnchorPos(pos) {
    const anchorEl = this.anchors[pos];
    if (!anchorEl || anchorEl.classList.contains('hidden')) return null;
    const rect = anchorEl.getBoundingClientRect();
    const canvasRect = this.flow.stage.getBoundingClientRect();
    return {
      x: rect.left + rect.width/2 - canvasRect.left,
      y: rect.top + rect.height/2 - canvasRect.top
    };
  }

  updatePosition() {
    this.el.style.transform = `translate(${this.x}px, ${this.y}px)`;
  }

  serialize() { 
    const base = {
      id: this.id, 
      type: this.type, 
      x: this.x, 
      y: this.y,
      w: this.w, 
      h: this.h, 
      title: this.title,
      key: this.key
    };

    if (this.type === 'trigger') {
      base.trigger = this.trigger;
      base.childNodes = this.childNodes;
    } else if (this.type === 'questions') {
      base.question = this.question;
      base.options = this.options;
    } else if (this.type === 'decision') {
      base.options = this.options;
    } else if (this.type === 'flow') {
      base.childNodes = this.childNodes;
    }

    return base;
  }

  destroy() { this.el.remove(); }
}

class Connector {
  constructor(flow, id, fromBox, fromAnchor, toBox, toAnchor) {
    this.flow = flow; this.id = id; this.fromBox = fromBox; this.fromAnchor = fromAnchor;
    this.toBox = toBox; this.toAnchor = toAnchor;
    this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    this.path.setAttribute('class', 'conn-line'); this.flow.svg.appendChild(this.path);
  }

  update() {
    const a = this.fromBox.getAnchorPos(this.fromAnchor);
    const b = this.toBox.getAnchorPos(this.toAnchor);
    if (a && b) {
      const offset = Math.abs(b.x - a.x) / 3;
      const d = `M ${a.x} ${a.y} C ${a.x + offset} ${a.y} ${b.x - offset} ${b.y} ${b.x} ${b.y}`;
      this.path.setAttribute('d', d);
    }
  }

  serialize() { 
    return {
      id: this.id, from: this.fromBox.id, fromAnchor: this.fromAnchor, 
      to: this.toBox.id, toAnchor: this.toAnchor
    }; 
  }

  destroy() { this.path.remove(); }
}

const rules = {
  trigger: ['questions'],
  questions: ['questions', 'decision', 'end'],
  decision: ['flow'],
  flow: ['questions', 'end'],
  end: []
};

const entradas = {
  trigger: { max: 0, permitidos: {} },
  questions: { max: Infinity, permitidos: { flow: 1, questions: Infinity, trigger: 1 } },
  decision: { max: Infinity, permitidos: { questions: Infinity } },
  flow: { max: Infinity, permitidos: { decision: Infinity } },
  end: { max: Infinity, permitidos: { flow: Infinity, questions: Infinity, decision: Infinity } }
};

class Flowchart {
  constructor() {
    this.stage = document.getElementById('canvas'); 
    this.svg = document.getElementById('svg');
    this.boxes = new Map(); 
    this.conns = new Map(); 
    this.boxCounter = 0; 
    this.connCounter = 0;
    this.pendingAnchor = null; 
    this._needsUpdate = false; 
    this._bindEvents();
  }

  _bindEvents() {
    document.getElementById('addTrigger').addEventListener('click', () => this.addBox('trigger'));
    document.getElementById('addQuestions').addEventListener('click', () => this.addBox('questions'));
    document.getElementById('addDecision').addEventListener('click', () => this.addBox('decision'));
    document.getElementById('addFlow').addEventListener('click', () => this.addBox('flow'));
    document.getElementById('addEnd').addEventListener('click', () => this.addBox('end'));
    document.getElementById('clearFlow').addEventListener('click', () => this.clear());

    this.stage.addEventListener('click', e => {
      const anchor = e.target.closest('.anchor:not(.hidden)');
      if (anchor) {
        const box = this.boxes.get(anchor.dataset.box);
        const pos = anchor.dataset.pos;

        if (this.pendingAnchor) {
          for (const conn of this.conns.values()) {
            if ((conn.fromBox === this.pendingAnchor.box && conn.toBox === box) || 
                (conn.fromBox === box && conn.toBox === this.pendingAnchor.box)) {
              this.pendingAnchor.el.classList.remove('active-anchor');
              this.pendingAnchor = null;
              return;
            }
          }
        }

        if (this.pendingAnchor && this.pendingAnchor.box === box && this.pendingAnchor.pos === pos) {
          this.pendingAnchor.el.classList.remove('active-anchor');
          this.pendingAnchor = null;
          return;
        }

        if (this.pendingAnchor && this.pendingAnchor.el) this.pendingAnchor.el.classList.remove('active-anchor');

        anchor.classList.add('active-anchor');

        if (this.pendingAnchor) {
          this.createConn(this.pendingAnchor.box, this.pendingAnchor.pos, box, pos);
          this.pendingAnchor.el.classList.remove('active-anchor');
          anchor.classList.remove('active-anchor');
          this.pendingAnchor = null;
        } else {
          this.pendingAnchor = { box, pos, el: anchor };
        }
        return;
      }

      if (this.pendingAnchor) {
        this.pendingAnchor.el.classList.remove('active-anchor');
        this.pendingAnchor = null;
      }
    });
  }

  addBox(type, x=60, y=60) {
    if (type === 'trigger' && Array.from(this.boxes.values()).some(b => b.type === 'trigger')) {
      return;
    }
    const id = `b${++this.boxCounter}`;
    const title = `${type.charAt(0).toUpperCase() + type.slice(1)} ${this.boxCounter}`;
    const box = new Box(this, id, type, x, y, title);
    this.boxes.set(id, box); 
    this.updateJSON(); 
    return box;
  }

  hasFlowBetween(fromBox, toBox) {
    const visited = new Set();
    const stack = [fromBox];
    while (stack.length) {
      const box = stack.pop();
      if (box === toBox) return true;
      visited.add(box);
      for (const conn of this.conns.values()) {
        if (conn.fromBox === box && !visited.has(conn.toBox)) {
          stack.push(conn.toBox);
        }
      }
    }
    return false;
  }

  createConn(fromBox, fromAnchor, toBox, toAnchor) {
    if (fromBox === toBox) return;

    if (!fromBox.isOutputAllowed(fromAnchor) || !toBox.isInputAllowed(toAnchor)) return;

    if (!rules[fromBox.type] || !rules[fromBox.type].includes(toBox.type)) return;

    const reglaEntrada = entradas[toBox.type];
    if (!reglaEntrada) return;

    const maxPorTipo = reglaEntrada.permitidos[fromBox.type];
    if (maxPorTipo === undefined) return;

    const count = Array.from(this.conns.values()).filter(c => c.toBox === toBox && c.fromBox.type === fromBox.type).length;
    if (count >= maxPorTipo) return;

    if (this.hasFlowBetween(fromBox, toBox)) return;

    if (toBox.type === 'end' && this.yaAlcanzaEnd(fromBox, toBox)) return;

    if (fromBox.type === 'trigger' || fromBox.type === 'flow') {
      if (!fromBox.childNodes.includes(toBox.id)) {
        fromBox.childNodes.push(toBox.id);
      }
    }

    const id = `c${++this.connCounter}`;
    const conn = new Connector(this, id, fromBox, fromAnchor, toBox, toAnchor);
    this.conns.set(id, conn);
    this.requestUpdate();
    this.updateJSON();
    return conn;
  }

  yaAlcanzaEnd(fromBox, endBox) {
    return this.hasFlowBetween(fromBox, endBox);
  }

  requestUpdate() {
    if (this._needsUpdate) return;
    this._needsUpdate = true;
    requestAnimationFrame(() => {
      this._needsUpdate = false;
      this._render();
    });
  }

  _render() {
    for (const c of this.conns.values()) c.update();
  }

  updateJSON() {
    const data = {
      boxes: [...this.boxes.values()].map(b => b.serialize()),
      conns: [...this.conns.values()].map(c => c.serialize())
    };
    document.getElementById('jsonView').textContent = JSON.stringify(data, null, 2);
  }

  clear() {
    for (const b of this.boxes.values()) b.destroy();
    this.boxes.clear();
    for (const c of this.conns.values()) c.destroy();
    this.conns.clear();
    this.boxCounter = 0;
    this.connCounter = 0;
    this.updateJSON();
  }
}

const FLOW = new Flowchart();
</script>
</body>
</html>